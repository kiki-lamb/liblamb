#ifndef LAMB_FX_CHAMBERLIN_H_
#define LAMB_FX_CHAMBERLIN_H_

////////////////////////////////////////////////////////////////////////////////

namespace lamb {

////////////////////////////////////////////////////////////////////////////////

 class fx_chamberlin {

////////////////////////////////////////////////////////////////////////////////

 public:

 public:
  q15n16s Q0;
  q24n8s  F0;

  q15n16s Q1;
  q24n8s  F1;
  q15n16s D0;
  q15n16s D1;
  q15n16s L;
  q15n16s H;
  q15n16s B;
  q15n16s N;

  q24n8 FS;
   
  static constexpr q8n24s PI2 = q8n24s::from_double(2*M_PI);

////////////////////////////////////////////////////////////////////////////////

 public:
  
  constexpr
  fx_chamberlin() :
    Q1(0), Q0(1, 0), F1(0), D0(0), D1(0), L(0), H(0), B(0), N(0),
    F0(1000, 0), FS(44100, 0) {
    
    f(F0);
    q(F1);
   }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  uint32_t fs() {
   return FS.characteristic();
  }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  void fs(uint32_t const & x) {
   FS = q24n8s(x, 0);
   f(F0);
  }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  q24n8s f() {
   return F0;
  }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  void f(q24n8s::type const & x) {
   F0 = q24n8s(x, 0);
   F1 = (F0 / FS) * PI2;
  }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  q15n16s q() {
   return Q0;
  }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  void q(double const & x) {
   q(q15n16s::from_double(x));
   }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  void q(q15n16s const & x) {
   Q0.val = x.val;
   Q1 = q15n16s(1,0) / Q0;
  }

////////////////////////////////////////////////////////////////////////////////

  constexpr
  q0n15s process(q0n15s I_) {

//  L = D1 + F1 * D0
//  H = I - L - Q1*D0
//  B = F1 * H + D0
//  N = H + L
//  D0 = B
//  D1 = L

    q15n16s I(I_.val << 1)            ;
    
    printf("% 6.9lf, ", double(I))    ;
    printf("% 6.9lf, ", double(F1))  ;        
    printf("% 6.9lf, ", double(Q1))   ;


    
    L  = D1 + D0 * F1                ;    printf("% 9.9lf, ",  double(L)) ;
    H  = I - L - (Q1*D0)              ;    printf("% 14.9lf, ", double(H)) ;
    B  = (H * F1)  + D0              ;    printf("% 9.9lf, ",  double(B)) ;
    N  = H  + L                       ;    printf("% 9.9lf, ",  double(N)) ;
    D0 = B                            ;    printf("% 9.9lf, ",  double(D0));
    D1 = L                            ;    printf("% 9.9lf  ",  double(D1));
        
    return q0n15s::from_double(0.0);
   }

////////////////////////////////////////////////////////////////////////////////
  
 };

////////////////////////////////////////////////////////////////////////////////
 
}

#endif /* LAMB_FX_CHAMBERLIN_H_ */
